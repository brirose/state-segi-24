---
title: "Mortality Assessment"
author: "Shive Lab (B. Baker)"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: cosmo
    toc: yes
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F, error = F)

library(here)
library(tidyverse)
library(janitor)
library(terra)
library(sf)
library(readxl)
library(leaflet)
library(RColorBrewer)
library(kableExtra)
library(lubridate)

```

This document contains code for a mortality assessment based on inputs of observed monarch tree mortality after a series of fires and fire severity as mapped through remote sensing of rdnbr on GEE (see complete_severity_layer_generation and combine_gee).

```{r import_data, include=FALSE}
#read in severity data

#four-class CBI severity for all fires that intersect groves, not clipped to groves
cbi_all <- st_read(here("data/spatial_data/outputs/cbi_all/cbi_all.shp")) %>% 
  filter(!str_detect(id, "2024")) #filter out fires that happened after surveys

#inventory of SEGI in SEKI, point data
sti <- st_read(here("data/spatial_data/inputs/forest/SEKI_STI_20211021.gdb"),layer = "SEKI_STI_pt") %>% 
  clean_names() %>%
  st_transform(crs(cbi_all)) %>% #uniform crs
  filter(diameter >= 121.92) %>% # filter for monarch trees >=4ft
  mutate(grove = case_when(
    grove == "Grant" ~ "General Grant",
    grove == "Oriole" ~ "Oriole Lake",
    T ~ grove))

#polygons of SEGI groves, "skinny"
groves <- st_read(here("data/spatial_data/inputs/forest/2023_GS_Groves_OTI_public.gdb"), layer = "OGS_Groves_2023_97_public") %>%
  clean_names() %>%
  st_transform(crs(cbi_all)) %>% #uniform crs
  st_cast("MULTIPOLYGON") %>% 
  st_make_valid()

```

```{r cbi}
#CBI severity for fires that intersect groves, clipped to groves

cbi_clipped <- st_intersection(cbi_all, groves)
cbi_clipped <- cbi_clipped %>% 
  rename("grov_nm" = "grove_name") %>% 
  select(grov_nm, id, burnsev, fire_yr) 

cbi_clipped$area_ha <- as.numeric(st_area(cbi_clipped))*0.0001 

```

## Load and clean data

Each dataset is slightly different, so I am loading each separately, cleaning them and then combining them. I then make them a spatial feature so that we can plot them on the map and find the severity.

```{r shive_input, results = F}
#Shive et all data for Pier, Railroad, Rough
#needs locations appended

multiple_shive_locs <- st_read(here("data/spatial_data/inputs/fire/SEGI_MortalityStudy_AllMonarchs/SEGI_MortalityStudy_AllMonarchs.shp")) %>% 
  clean_names() %>% 
  mutate(easting = sf::st_coordinates(.)[,1],
         northing = sf::st_coordinates(.)[,2])

multiple_shive <- read_csv(here("data/plot_data/ShiveEtal_MortStudy_AllSEGIData_AllGroves_2022.csv")) %>%
  clean_names() %>% 
  left_join(multiple_shive_locs) %>% 
  rename(
    survey_fire = fire,
    id = tree_number,
    grove = grove_name,
    postfire_status = live_status2020
    ) %>% 
  mutate(
    survey_year = 2020,
    fire_year = survey_year-yrs_post_fire,
    source = "Shive etal, Mortality Study",
    prefire_status = "unknown"
    ) %>% 
  select(id, grove, survey_year, easting, northing, postfire_status, prefire_status, source, survey_fire, dbh_cm)


```



```{r ucb_input}
#Data from Hardlund, monarch locations already corrected
castle_ucb <- read_csv(here("data/plot_data/UCB_CastleSeverity_15Nov23.csv")) %>% 
  clean_names() %>% 
  mutate(
    prefire_status = case_when( #pull prefire dead from notes
      str_detect(notes, "[Dd] pre") ~ "dead", 
      str_detect(notes, "[Dd] prior") ~ "dead",
      str_detect(notes, "[Dd] before") ~ "dead",
      T ~ "live"),
    source = "UCB, Hardlund",
    survey_fire = "post_castle",
    survey_year = 2021
    ) %>% 
  rename(
    postfire_status = status,
    id = monarch_num,
    grove = site,
    easting = plot_easting,
    northing = plot_northing
    ) %>% 
  select(id, grove, survey_year, easting, northing, postfire_status, prefire_status, source, survey_fire, dbh_cm)

```

```{r usgs_mMort}

#USGS monarch mortality study data, collected for KNP and Castle
#prefire live status unknown
#includes smaller trees

sti_status <- sti %>% 
  select(tree_id, status)

mort_usgs <- read_csv(here("data/plot_data/USGS_MortalityStudy_SEGItrees_09Sept24.csv")) %>% 
  clean_names() %>% 
  rename(
    dbh_cm = diameter,
    postfire_status = last_known_status,
    easting = utm_e,
    northing = utm_n,
    id = tree_id
  ) %>% 
  left_join(sti_status, by = join_by(id == tree_id)) %>%
  rename(prefire_status = status) %>% 
  mutate(
    prefire_status = case_when(
      !is.na(prefire_status) ~ prefire_status,
      postfire_status == "Alive" ~ "Alive",
      T ~ "unknown"
    ),
    survey_year = as.numeric(str_extract(last_observation_date, "(?<=/)\\d{4}")),
    survey_fire = case_when(
      within_knp == "Y" ~ "post_knp",
      within_castle == "Y" ~ "post_castle",
      T ~ "other"),
    source = "USGS, mortality"
  ) %>% 
  
  select(id, grove, survey_year, easting, northing, postfire_status, prefire_status, source, survey_fire, dbh_cm)

#check to make sure survey year falls after the most recent fire experienced
summary_usgs <- mort_usgs %>% 
  summarise(.by = c(survey_fire, survey_year, grove), count = n())
#surveys done following both KNP and castle; Eden creek (in coffeepot) surveyed; will need to exclude severity of coffeepot in mort assessment

```

```{r usgs_ff}

#USGS fire and fuels plot data; some may be in burned areas
#in lat/long
#needs to be filtered by species and size
#prefire live status unknown

ff_usgs_plot <- read_excel(here("data/plot_data/USGS_FireAndFuels_SEGI_plot_data_15Aug24.xlsx"), "plotMetadata") %>% 
  clean_names() %>% 
  select(plot_id, visit_date, lat, lon)

ff_usgs <- read_excel(here("data/plot_data/USGS_FireAndFuels_SEGI_plot_data_15Aug24.xlsx"), "trees") %>% 
  clean_names() %>% 
  left_join(ff_usgs_plot, by = join_by(plot_id)) %>% 
  filter(sp == "SEGI") %>% 
  mutate(
    id = paste(plot_id, canopy_id),
    survey_year = year(ymd(visit_date)),
    source = "USGS, fire & fuels",
    prefire_status = "unknown",
    grove = "NA",
    survey_fire = "NA"
  ) %>% 
  rename(
    postfire_status = ld,
    dbh_cm = dbh) %>% 
  select(id, grove, survey_year, lat, lon, postfire_status, prefire_status, source, survey_fire, dbh_cm)
  

```

```{r usfs_input}
#Meyer input

#plot inventory info usfs castle
castle_meyer_plot <- read_excel(here("data/plot_data/meyer/CastleFireGroveData_2023_combined.xlsx"), sheet = "PlotData") %>% 
  clean_names() %>% 
  select(grove, plot_no, date)

#usfs data on castle fire
castle_meyer <- read_excel(here("data/plot_data/meyer/CastleFireGroveData_2023_combined.xlsx"), sheet = "Monarchs") %>% 
  clean_names() %>% 
  left_join(castle_meyer_plot, join_by(grove == grove, plot_no_nearby == plot_no)) %>% 
  mutate(source = "USFS, Meyer", survey_fire = "post_castle", #include relevant info
         id = paste(grove, plot_no_nearby, monarch_no, sep = ""),
         survey_year = year(ymd(date)))%>% 
  rename(date_surveyed = date) %>% 
  select(id, grove, survey_year, easting, northing, postfire_status, prefire_status, source, survey_fire, gps_offset_m, dbh_cm, gps_offset_deg)


#usfs plot data knp
knp_meyer_plot <- read_excel(here("data/plot_data/meyer/PostfireSequoiaGroveData_2024_FreemanCrk&REMO.v2.reduced.xlsx"), sheet = "PlotData") %>% 
  clean_names() %>% 
  select(grove, plot_no, date)

#USFS data on KNP complex
knp_meyer <- read_excel(here("data/plot_data/meyer/PostfireSequoiaGroveData_2024_FreemanCrk&REMO.v2.reduced.xlsx"), sheet = "Monarchs") %>% 
  clean_names() %>% 
  filter(removed == "no") %>% 
  left_join(knp_meyer_plot, join_by(grove == grove, plot_no_nearby == plot_no)) %>% 
  mutate(source = "USFS, Meyer", survey_fire = "post_knp",
         id = paste(grove, plot_no_nearby, monarch_no, sep = ""),
         survey_year = year(ymd(date))) %>% 
  select(id, grove, survey_year, easting, northing, postfire_status, prefire_status, source, survey_fire, gps_offset_m, dbh_cm, gps_offset_deg)


#usfs plot data windy
windy_meyer_plot <- read_excel(here("data/plot_data/meyer/WindyFireSequoiaGroveData.reduced.v2.xlsx"), sheet = "PlotData") %>% 
  clean_names() %>% 
  select(grove, plot_no, date)

#usfs data on windy fire
windy_meyer <- read_excel(here("data/plot_data/meyer/WindyFireSequoiaGroveData.reduced.v2.xlsx"), sheet = "Monarchs") %>% 
  clean_names() %>% 
  left_join(windy_meyer_plot, join_by(grove == grove, plot_no == plot_no)) %>% 
  mutate(source = "USFS, Meyer", survey_fire = "post_windy",
         prefire_status = case_when(!is.na(dead_before_fire) ~ "Dead",
                              TRUE ~ "Live"),
         id = paste(monarch_no, plot_no, sep = ""),
         survey_year = year(ymd(date)))%>%
  rename(postfire_status = status) %>% 
  select(id, grove, survey_year, easting, northing, postfire_status, prefire_status, source, survey_fire, gps_offset_m, dbh_cm, gps_offset_deg)

#combine into one
meyers_combined <- castle_meyer %>% 
  rbind(knp_meyer) %>% 
  rbind(windy_meyer)

#correct points; points were taken away from the location of the SEGI
#the following is trig to move them to the correct spot
#requires that we know distance and degrees offset from tree and dbh

meyers_corrected <- meyers_combined %>% 
  mutate(
    dbh_cm = replace_na(dbh_cm, 0), #fill NA dbh with 0
    total_offset_m = gps_offset_m + dbh_cm/100/2, #add radius to offset to put point on center
    gps_reset_radians = -1 *((gps_offset_deg * pi) / (180)),# convert offset to radians & invert 
    new_easting = easting + (sin(gps_reset_radians) * total_offset_m), #use trig to offset x
    new_northing = northing + (cos(gps_reset_radians) * total_offset_m) #use trig to offset y
  ) %>% 
  rename(
    "old_easting" = "easting",
    "old_northing" = "northing",
    "easting" = "new_easting",
    "northing" = "new_northing"
  ) %>% 
  select(!c(old_easting, old_northing)) %>% 
  filter(
    !id %in% c("LM03212", #well outside of Long Meadow 
               "LM03312", #well outside of Long Meadow 
               "LM03412", #well outside of Long Meadow 
               "LM03512", #well outside of Long Meadow 
               "MT198", #coordinates wrong
               "MT199", #coordinates wrong
               "Mt Home86"), #coordinates wrong
    !str_detect(id, "Middle Tule20\\d+") #outside of castle burn perim
    ) 

  

```

```{r combine_inputs}
#combine inputs
monarchs_combined <- meyers_corrected %>% 
  bind_rows(multiple_shive) %>% 
  bind_rows(castle_ucb) %>% 
  bind_rows(mort_usgs) %>% 
  #bind_rows(ff_usgs) %>% #needs to be converted to utm still
  drop_na(easting, northing) %>% 
  st_as_sf(coords = c("easting", "northing"), crs = 32611) %>%  #wgs84, UTM zone 11N
  st_transform(crs(cbi_all))

```

## Calculate Mortality Rates

Now, i calculate mortality rate based on trees prefire vs postfire status.

```{r binary_severity}
#need to add filter for tree size
monarchs_binary <- monarchs_combined %>% 
  filter(dbh_cm >= 121.92) %>% 
  mutate(
    postfire_status = case_when(
      postfire_status %in% c("L", "Live", "Alive", "live", "1") ~ 1,
      postfire_status %in% c("D", "dead", "Dead", "0") ~ 0,
      T ~ -999
    ),
    prefire_status = case_when(
     prefire_status  %in% c("L", "Live", "Alive", "live", "1", "unknown") ~ 1, #assuming unknown prefire status were alive, may slightly overcount mortality if a few were dead prefire
     prefire_status %in% c("D", "dead", "Dead", "0") ~ 0,
      T ~ -999
    )
  ) %>% 
  # filter for trees of known status not known to be dead prefire
  filter(prefire_status == 1 , postfire_status >= 0) 


#pull severity info 
monarchs_severity <- monarchs_binary %>% 
  st_join(cbi_all) #pull severity info; i am using the all-sierra layer here to ensure that trees that fall slightly outside of the mapped grove boundaries based on field or mapping errors are still included in the analysis
  
  
#the cbi_all layer has all fires, but the observation data only are for recent fires, so remove duplicates
monarch_severity_duplicated <- monarchs_severity %>% 
  mutate(dups = duplicated(id.x)) %>% 
  filter(dups == T) #makes df of second time a tree ID is in the initial df

monarchs_severity <- monarchs_severity %>% 
  filter(!id.x %in% monarch_severity_duplicated$id.x) %>% # remove all duplicated IDs
  bind_rows(monarch_severity_duplicated) %>% #bind this back bc contains the second obs which after the join is the more recent fire
  rename("tree_id" = "id.x",
         "fire_id" = "id.y") %>% 
  drop_na(burnsev) %>% #remove trees outside burn areas (by location or bc of bad coords)
  mutate(measure_delay = as.numeric(fire_yr)-as.numeric(survey_year)) %>% 
  select(tree_id, grove, postfire_status, prefire_status, survey_year, fire_yr, measure_delay, fire_id,  burnsev, source) 

#need to do more checking about the NA monarchs after join
#also some of them are out of the fire footprint on the spatial data, but have field severity written in; replace with field severity there or remove from dataset?

#dir.create(here("data/spatial_data/outputs/monarchs_severity"))
# st_write(monarchs_severity, here("data/spatial_data/outputs/monarchs_severity/monarchs_severity_4Nov24.shp"), append = F)

```

### Mortality rate by fire

This is the aggregation level that is typically used in the literature.

```{r mortality_fire}

#calculate mortality rates by fire
monarchs_mortality_fire <- monarchs_severity %>% 
  st_drop_geometry() %>% 
  summarise(.by = c(fire_id, burnsev), mortality = 1-(sum(postfire_status)/sum(prefire_status)))

#determine range of mortality when aggregated by fire
mortality_fire <- monarchs_mortality_fire %>% 
  summarize(.by = burnsev,
            min_fire = min(mortality),
            max_fire = max(mortality),
            avg_fire = mean(mortality)) %>% 
  arrange(burnsev)

kable(mortality_fire,
      digits = 3,
      caption = "SEGI estimated mortality rates when aggregated by fire")
```

### Mortality by year

Out of interest, we also tried an aggregation by year.

```{r mortality_year}
#calculate mortality rates by year
monarchs_mortality_year <- monarchs_severity %>% 
  st_drop_geometry() %>% 
  summarise(.by = c(fire_yr, burnsev), 
            mortality = 1-(sum(postfire_status)/sum(prefire_status)))

#determine range of mortality when aggregated by year
mortality_year <- monarchs_mortality_year %>% 
  summarize(.by = burnsev,
            min_yr = min(mortality),
            max_yr = max(mortality),
            avg_yr = mean(mortality))

kable(mortality_year,
      digits = 3,
      caption = "SEGI estimated mortality rates when aggregated by year")

```

Decision needed: which aggregation will we want to use? Likely should wait until we have enough actual data, rather than just the USFS

```{r check_debug}

# plot to check and debug

# ggplot()+
#   geom_sf(monarchs_binary, mapping = aes())
# 
# monarchs_wgs84 <- st_transform(monarchs_binary, 4326)
# cbi_wgs84 <- st_transform(cbi_all, 4326)
# perimeters_segi <- st_read("data/spatial_data/outputs/perimeters_segi/perimeters_segi.shp") %>% 
#   st_transform(4326)

# 
# debug_map <- leaflet() %>% 
#   addTiles() %>% 
#   setView(lng = -118.5, lat = 36.5, zoom = 10) %>% 
#   #  addPolygons(data = ba_additional, opacity = 1) %>% 
#   #addPolygons(data = groves, color = "black", opacity = 1, fillOpacity = 0) %>% 
#     # addPolygons(data = cbi_wgs84, 
#     #           color = "#444444", weight = 1, smoothFactor = 0.5, opacity = 1.0, 
#     #           fillOpacity = 0.5, fillColor = ~colorFactor("YlOrRd", domain = cbi_wgs84$burnsev)(burnsev))%>% 
#   addCircleMarkers(data = monarchs_wgs84, stroke = F, fillOpacity = 0.8, radius = 3, color = "black") %>% 
#   addLegend(pal = colorFactor("YlOrRd", domain = cbi_wgs84$burnsev), values = cbi_wgs84$burnsev)
# 
# debug_map

```

## Estimate SEGI mortality from fires

Now that we have ranges of mortality for each severity level, we can use these to estimate mortality.

Here i calculate the proportion of area that experienced each severity of fire

```{r severity_area}

total_area_ha = sum(groves$acres)*0.404686

#here i calculate ha of each severity in each year
severity_annual <- cbi_clipped %>% 
  st_drop_geometry() %>% 
  summarise(.by = c(fire_yr, burnsev), total_ha = sum(area_ha)) %>% 
  mutate(prop_grove_area = total_ha/total_area_ha) %>% 
  arrange(fire_yr, burnsev)

severity_annual_wider <- severity_annual %>% 
  mutate(perc_grove_area = prop_grove_area*100) %>% 
  select(-prop_grove_area) %>% 
  pivot_wider(names_from = burnsev, values_from = c(total_ha, perc_grove_area), values_fill = 0) %>% 
  arrange(fire_yr)

kable(severity_annual_wider, 
      digits = 2,
      caption = "Area and percent of grove area experiencing fire severity annually 1984-2023")

#here i calculate ha of each severity since 1984
severity_total <- cbi_clipped %>% 
  st_drop_geometry() %>% 
  summarise(.by = c(burnsev), total_ha = sum(area_ha)) %>% 
  mutate(prop_grove_area = total_ha/total_area_ha) %>% 
  arrange(burnsev)

kable(severity_total, 
      digits = 2,
      caption = "Area and proportion of grove area experiencing fire severity 1984-2023")
```

First, I put together some quick mortality estimates that utilize the `trees_ha` trees/ha value.

I did this as annual estimates.

```{r annual_mort}
#annual mortality (without removal of SEKI areas that have counts)

trees_ha = 2.61/0.404686 #there are an estimated 2.61 segi trees per acre, converted to ha

trees_total = total_area_ha*trees_ha

annual_mort_est <- severity_annual %>% 
  left_join(mortality_fire) %>% 
  left_join(mortality_year) %>% 
  mutate(mort_min_fire = round(total_ha*trees_ha*min_fire, 1),
         mort_min_perc_fire = prop_grove_area*min_fire,
         mort_max_fire = round(total_ha*trees_ha*max_fire, 1),
         mort_max_perc_fire = prop_grove_area*max_fire,
         mort_avg_fire = round(total_ha*trees_ha*avg_fire, 1),
         mort_avg_perc_fire = prop_grove_area*avg_fire,
         mort_min_yr = round(total_ha*trees_ha*min_yr, 1),
         mort_min_perc_yr = prop_grove_area*min_yr,
         mort_max_yr = round(total_ha*trees_ha*max_yr, 1),
         mort_max_perc_yr = prop_grove_area*max_yr,
         mort_avg_yr = round(total_ha*trees_ha*avg_yr, 1),
         mort_avg_perc_yr = prop_grove_area*avg_yr) %>% 
  select(!c(min_fire, max_fire, avg_fire, min_yr, max_yr, avg_yr)) %>% 
  arrange(fire_yr, burnsev)

kable(annual_mort_est, 
      digits = 2,
      caption = "SEGI annual mortality from fire estimates using only trees per ha")

```

...and as total mortality by severity class

```{r total_mort}
#total mortality (without removal of SEKI areas that have counts)

total_mort_est <- severity_total %>% 
  st_drop_geometry() %>% 
  left_join(mortality_fire) %>% 
  left_join(mortality_year) %>% 
  mutate(mort_min_fire = round(total_ha*trees_ha*min_fire, 1),
         mort_min_perc_fire = prop_grove_area*min_fire,
         mort_max_fire = round(total_ha*trees_ha*max_fire, 1),
         mort_max_perc_fire = prop_grove_area*max_fire,
         mort_avg_fire = round(total_ha*trees_ha*avg_fire, 1),
         mort_avg_perc_fire = prop_grove_area*avg_fire,
         mort_min_yr = round(total_ha*trees_ha*min_yr, 1),
         mort_min_perc_yr = prop_grove_area*min_yr,
         mort_max_yr = round(total_ha*trees_ha*max_yr, 1),
         mort_max_perc_yr = prop_grove_area*max_yr,
         mort_avg_yr = round(total_ha*trees_ha*avg_yr, 1),
         mort_avg_perc_yr = prop_grove_area*avg_yr) %>% 
  select(!c(min_fire, max_fire, avg_fire, min_yr, max_yr, avg_yr)) %>% 
  arrange(burnsev)

kable(total_mort_est, 
      digits = 2,
      caption = "SEGI total mortality from fire estimates using only trees per ha")
```

## Compare STI vs average per ha at grove level

Here i look at how the estimates change if I use the sti in SEKI to make the estimates. I estimate by grove and do the estimates by sti and by average trees mortality ranges.

We expect that in some groves the sti should be an undercount since it does not cover entire grove area (list here)

```{r sti_mort}

#severity experienced by each tree in the STI
sti_sev <- sti %>% 
  st_join(cbi_all) %>%#here i include all times a tree experienced fire
  st_drop_geometry() %>% 
  drop_na(burnsev) %>%  #drop trees that did not experience fire
  summarise(.by = c(grove, burnsev), tree_ct = n())

#severity area in each grove
grove_sev_area <- cbi_clipped %>% 
  st_drop_geometry() %>% 
  summarise(.by = c(grov_nm, burnsev), area_ha = sum(area_ha)) %>% 
  mutate(grov_nm = case_when(grov_nm == "Devil's Canyon" ~ "Devils Canyon", T ~ grov_nm))

#total grove area
grove_area <- groves %>% #convert multisurface to multipolygon
  st_drop_geometry() %>% 
  select(grove_name, acres) %>% 
  mutate(grove_ha = acres*0.404686,
         grove_name = case_when(
           grove_name == "Devil's Canyon" ~ "Devils Canyon",
           T ~ grove_name))%>% 
  select(!acres) %>% 
  left_join(grove_sev_area, join_by(grove_name == grov_nm)) %>% 
  drop_na(burnsev)

#combine to have count of trees in each grove that experienced each severity
#calculate count of trees that died in each, and trees that died per acre in each grove
#use both mortality ranges and calculate corresponding values by average density
sti_mortality_est <- sti_sev %>% 
  left_join(mortality_fire) %>% 
  left_join(mortality_year) %>% 
  left_join(grove_area, join_by(grove == grove_name, burnsev == burnsev)) %>% 
  mutate(
    #calculate based on STI counts
    sti_min_ct_fire = round(tree_ct*min_fire, 1),
    sti_min_perha_fire = sti_min_ct_fire/grove_ha,
    sti_max_ct_fire = round(tree_ct*max_fire, 1),
    sti_max_perha_fire = sti_max_ct_fire/grove_ha,
    sti_avg_ct_fire = round(tree_ct*avg_fire, 1),
    sti_avg_perha_fire = sti_avg_ct_fire/grove_ha,
    sti_min_ct_yr = round(tree_ct*min_yr, 1),
    sti_min_perha_yr = sti_min_ct_yr/grove_ha,
    sti_max_ct_yr = round(tree_ct*max_yr, 1),
    sti_max_perha_yr = sti_max_ct_yr/grove_ha,
    sti_avg_ct_yr = round(tree_ct*avg_yr, 1),
    sti_avg_perha_yr = sti_avg_ct_yr/grove_ha,
    #estimates based on trees/ha
    est_min_ct_fire = round(area_ha*trees_ha*min_fire, 1),
    est_min_perha_fire = est_min_ct_fire/grove_ha,
    est_max_ct_fire = round(area_ha*trees_ha*max_fire, 1),
    est_max_perha_fire = est_max_ct_fire/grove_ha,
    est_avg_ct_fire = round(area_ha*trees_ha*avg_fire, 1),
    est_avg_perha_fire = est_avg_ct_fire/grove_ha,
    est_min_ct_yr = round(area_ha*trees_ha*min_yr, 1),
    est_min_perha_yr = est_min_ct_yr/grove_ha,
    est_max_ct_yr = round(area_ha*trees_ha*max_yr, 1),
    est_max_perha_yr = est_max_ct_yr/grove_ha,
    est_avg_ct_yr = round(area_ha*trees_ha*avg_yr, 1),
    est_avg_perha_yr = est_avg_ct_yr/grove_ha)%>% 
  select(!tree_ct:area_ha) %>% 
  pivot_longer(sti_min_ct_fire:est_avg_perha_yr) %>% 
  separate_wider_delim(name, "_", 
                       names = c("method", "statistic", "measure", "aggregation"))

```

The following are some visuals to compare some of these values. I have yet to do any actual statistical analysis.

```{r compare_sti_scatter, fig.width=10, fig.height=14}

method_comparison_fire <- sti_mortality_est %>% 
  filter(aggregation == "fire", measure == "perha") %>% 
  as.data.frame()
  
#plot values for fire aggregated mortality rates
ggplot(method_comparison_fire, aes(x = grove, y = value)) +
  geom_point(aes(color = method))+
  facet_wrap(vars(burnsev))+
  coord_flip()+
  theme_minimal()+
  xlab(NULL)+
  labs(title = "Comparison of trees/ha mortality based on STI counts and average trees per ha across\ngroves using fire aggregate mortality rates", y = "Tree mortality per hectare")+
  theme(plot.title.position = "plot")

```

```{r compare_sti_box}

# difference between measures
difference_mortality <- sti_mortality_est %>% 
  pivot_wider(names_from = method, values_from = value) %>% 
  mutate(diff = sti-est,
         burnsev = as.factor(burnsev)) %>% 
  filter(measure == "perha")

#boxplot showing the variance in differences between estimates
ggplot(difference_mortality, aes(burnsev, diff))+
  facet_wrap(vars(aggregation, statistic))+
  geom_boxplot()+
  labs(title = "Difference between trees/ha mortality based on STI counts and average\ntrees per ha in SEKI SEGI groves")


```

The following describe the difference between methods at the grove level (ie estimated count of mortality per grove)

```{r compare_sti_groves}

method_comparison_fire_grove <- sti_mortality_est %>% 
  filter(measure == "ct") %>% 
  as.data.frame() %>% 
  summarise(.by = c(aggregation, method, statistic, burnsev), per_grove = sum(value)/length(unique(sti_mortality_est$grove))) %>% 
  pivot_wider(names_from = statistic, values_from = per_grove)
  
kable(method_comparison_fire_grove, 
      digits = 2,
      caption = "SEGI average mortality per grove from fire and annual estimates using trees per ha and STI")

```
